
    alter table if exists author 
        drop constraint if exists FK_6a4p11f1bt171w09oo06m0wag;

    alter table if exists author 
        drop constraint if exists FK_p0ysrub11cm08xnhrbrfrvudh;

    alter table if exists comment 
        drop constraint if exists FK_9aq5p2jgf17y6b38x5ayd90oc;

    alter table if exists comment 
        drop constraint if exists FK_6oqj6vquqc33cyawn853hfu5g;

    alter table if exists comment 
        drop constraint if exists FK_h9t5eaaqhnqwrc92rhryyvdcf;

    alter table if exists comment 
        drop constraint if exists FK_3tfkdcmf6rg6hcyiu8t05er7x;

    alter table if exists external_ref 
        drop constraint if exists FK_4g2i2qry4941xmqijgeo8ns2h;

    alter table if exists external_ref 
        drop constraint if exists FK_bu7q5itmt7w7q1bex049xvac7;

    alter table if exists external_ref 
        drop constraint if exists FK_f7igpcpvgcmdfb7v3bgjluqsf;

    alter table if exists id_mapper 
        drop constraint if exists FK_qiy281xsleyhjgr0eu1sboagm;

    alter table if exists instance 
        drop constraint if exists FK_pr2f6peqhnx9rjiwkr5jgc5be;

    alter table if exists instance 
        drop constraint if exists FK_30enb6qoexhuk479t75apeuu5;

    alter table if exists instance 
        drop constraint if exists FK_o80rrtl8xwy4l3kqrt9qv0mnt;

    alter table if exists instance 
        drop constraint if exists FK_gdunt8xo68ct1vfec9c6x5889;

    alter table if exists instance 
        drop constraint if exists FK_gtkjmbvk6uk34fbfpy910e7t6;

    alter table if exists instance 
        drop constraint if exists FK_hb0xb97midopfgrm2k5fpe3p1;

    alter table if exists instance 
        drop constraint if exists FK_lumlr5avj305pmc4hkjwaqk45;

    alter table if exists instance_note 
        drop constraint if exists FK_bw41122jb5rcu8wfnog812s97;

    alter table if exists instance_note 
        drop constraint if exists FK_he1t3ug0o7ollnk2jbqaouooa;

    alter table if exists instance_note 
        drop constraint if exists FK_f6s94njexmutjxjv8t5dy1ugt;

    alter table if exists name 
        drop constraint if exists FK_airfjupm6ohehj1lj82yqkwdx;

    alter table if exists name 
        drop constraint if exists FK_coqxx3ewgiecsh3t78yc70b35;

    alter table if exists name 
        drop constraint if exists FK_3pqdqa03w5c6h4yyrrvfuagos;

    alter table if exists name 
        drop constraint if exists FK_sgvxmyj7r9g4wy9c4hd1yn4nu;

    alter table if exists name 
        drop constraint if exists FK_rp659tjcxokf26j8551k6an2y;

    alter table if exists name 
        drop constraint if exists FK_sk2iikq8wla58jeypkw6h74hc;

    alter table if exists name 
        drop constraint if exists FK_5fpm5u0ukiml9nvmq14bd7u51;

    alter table if exists name 
        drop constraint if exists FK_bcef76k0ijrcquyoc0yxehxfp;

    alter table if exists name 
        drop constraint if exists FK_156ncmx4599jcsmhh5k267cjv;

    alter table if exists name 
        drop constraint if exists FK_dd33etb69v5w5iah1eeisy7yt;

    alter table if exists name 
        drop constraint if exists FK_ai81l07vh2yhmthr3582igo47;

    alter table if exists name 
        drop constraint if exists FK_5gp2lfblqq94c4ud3340iml0l;

    alter table if exists name 
        drop constraint if exists FK_dqhn53mdh0n77xhsw7l5dgd38;

    alter table if exists name_part 
        drop constraint if exists FK_s13ituehdpf6uh859umme7g1j;

    alter table if exists name_part 
        drop constraint if exists FK_pj38oewhgjq8rp08fc9cviteu;

    alter table if exists name_rank 
        drop constraint if exists FK_p3lpayfbl9s3hshhoycfj82b9;

    alter table if exists name_rank 
        drop constraint if exists FK_r67um91pujyfrx7h1cifs3cmb;

    alter table if exists name_status 
        drop constraint if exists FK_swotu3c2gy1hp8f6ekvuo7s26;

    alter table if exists name_status 
        drop constraint if exists FK_g4o6xditli5a0xrm6eqc6h9gw;

    alter table if exists name_tag_name 
        drop constraint if exists FK_22wdc2pxaskytkgpdgpyok07n;

    alter table if exists name_tag_name 
        drop constraint if exists FK_2uiijd73snf6lh5s6a82yjfin;

    alter table if exists name_tree_path 
        drop constraint if exists FK_j4j0kq9duod9gm019pl1xec7c;

    alter table if exists name_tree_path 
        drop constraint if exists FK_try5dwb6jcy5fngk09bf7f7on;

    alter table if exists name_tree_path 
        drop constraint if exists FK_sfj3hoevcuni3ak7no6byjp3;

    alter table if exists name_tree_path 
        drop constraint if exists FK_3xnmxe5p6ed258euacrfflwrj;

    alter table if exists name_type 
        drop constraint if exists FK_10d0jlulq2woht49j5ccpeehu;

    alter table if exists name_type 
        drop constraint if exists FK_5r3o78sgdbxsf525hmm3t44gv;

    alter table if exists nomenclatural_event_type 
        drop constraint if exists FK_ql5g85814a9y57c1ifd0nkq3v;

    alter table if exists nsl_simple_name 
        drop constraint if exists FK_lgtnu32ysbg6l2ys5d6bhfgmq;

    alter table if exists nsl_simple_name 
        drop constraint if exists FK_on28vygd1e7aqn9owbhv3u23h;

    alter table if exists nsl_simple_name 
        drop constraint if exists FK_ctg301hhg3x41rjl09d7noti1;

    alter table if exists nsl_simple_name 
        drop constraint if exists FK_k4ryd8xarm9hhk1aitqtfg0tb;

    alter table if exists nsl_simple_name 
        drop constraint if exists FK_bexlla3pvlm2x8err16puv16f;

    alter table if exists nsl_simple_name 
        drop constraint if exists FK_gbcxpwubk8cdlh5fxnd3ln4up;

    alter table if exists nsl_simple_name 
        drop constraint if exists FK_kquvd2hkcl7aj2vhylvp1k7vb;

    alter table if exists nsl_simple_name 
        drop constraint if exists FK_59i6is32bt6v19i51ql9n2r9i;

    alter table if exists nsl_simple_name 
        drop constraint if exists FK_mvjeehgt584v9ep11ixe1iyok;

    alter table if exists nsl_simple_name 
        drop constraint if exists FK_rpqdbhi21sdix5tmmj5ul61su;

    alter table if exists ref_type 
        drop constraint if exists FK_51alfoe7eobwh60yfx45y22ay;

    alter table if exists reference 
        drop constraint if exists FK_p8lhsoo01164dsvvwxob0w3sp;

    alter table if exists reference 
        drop constraint if exists FK_3min66ljijxavb0fjergx5dpm;

    alter table if exists reference 
        drop constraint if exists FK_1qx84m8tuk7vw2diyxfbj5r2n;

    alter table if exists reference 
        drop constraint if exists FK_am2j11kvuwl19gqewuu18gjjm;

    alter table if exists reference 
        drop constraint if exists FK_cr9avt4miqikx4kk53aflnnkd;

    alter table if exists reference 
        drop constraint if exists FK_a98ei1lxn89madjihel3cvi90;

    alter table if exists reference 
        drop constraint if exists FK_dm9y4p9xpsc8m7vljbohubl7x;

    alter table if exists trashed_item 
        drop constraint if exists FK_bd6arfjuj28nolsc58i345ybg;

    alter table if exists tree_arrangement 
        drop constraint if exists FK_fvfq13j3dqv994o9vg54yj5kk;

    alter table if exists tree_link 
        drop constraint if exists FK_tgankaahxgr4p0mw4opafah05;

    alter table if exists tree_link 
        drop constraint if exists FK_kqshktm171nwvk38ot4d12w6b;

    alter table if exists tree_link 
        drop constraint if exists FK_2dk33tolvn16lfmp25nk2584y;

    alter table if exists tree_node 
        drop constraint if exists FK_nlq0qddnhgx65iojhj2xm8tay;

    alter table if exists tree_node 
        drop constraint if exists FK_1g9477sa8plad5cxkxmiuh5b;

    alter table if exists tree_node 
        drop constraint if exists FK_eqw4xo7vty6e4tq8hy34c51om;

    alter table if exists tree_node 
        drop constraint if exists FK_gc6f9ykh7eaflvty9tr6n4cb6;

    alter table if exists tree_node 
        drop constraint if exists FK_sbuntfo4jfai44yjh9o09vu6s;

    alter table if exists tree_node 
        drop constraint if exists FK_budb70h51jhcxe7qbtpea0hi2;

    alter table if exists tree_node 
        drop constraint if exists FK_pc0tkp9bgp1cxull530y60v46;

    alter table if exists tree_node 
        drop constraint if exists FK_4y1qy9beekbv71e9i6hto6hun;

    alter table if exists tree_node 
        drop constraint if exists FK_t6kkvm8ubsiw6fqg473j0gjga;

    alter table if exists tree_node 
        drop constraint if exists FK_16c4wgya68bwotwn6f50dhw69;

    alter table if exists tree_node 
        drop constraint if exists FK_oge4ibjd3ff3oyshexl6set2u;

    alter table if exists tree_uri_ns 
        drop constraint if exists FK_q9k8he941kvl07j2htmqxq35v;

    drop table if exists author cascade;

    drop table if exists comment cascade;

    drop table if exists db_version cascade;

    drop table if exists delayed_jobs cascade;

    drop table if exists external_ref cascade;

    drop table if exists help_topic cascade;

    drop table if exists id_mapper cascade;

    drop table if exists instance cascade;

    drop table if exists instance_note cascade;

    drop table if exists instance_note_key cascade;

    drop table if exists instance_type cascade;

    drop table if exists language cascade;

    drop table if exists locale cascade;

    drop table if exists name cascade;

    drop table if exists name_category cascade;

    drop table if exists name_group cascade;

    drop table if exists name_part cascade;

    drop table if exists name_rank cascade;

    drop table if exists name_status cascade;

    drop table if exists name_tag cascade;

    drop table if exists name_tag_name cascade;

    drop table if exists name_tree_path cascade;

    drop table if exists name_type cascade;

    drop table if exists namespace cascade;

    drop table if exists nomenclatural_event_type cascade;

    drop table if exists notification cascade;

    drop table if exists nsl_simple_name cascade;

    drop table if exists ref_author_role cascade;

    drop table if exists ref_type cascade;

    drop table if exists reference cascade;

    drop table if exists trashed_item cascade;

    drop table if exists trashing_event cascade;

    drop table if exists tree_arrangement cascade;

    drop table if exists tree_event cascade;

    drop table if exists tree_link cascade;

    drop table if exists tree_node cascade;

    drop table if exists tree_uri_ns cascade;

    drop table if exists user_query cascade;

    drop table if exists why_is_this_here cascade;

    drop sequence hibernate_sequence;

    drop sequence nsl_global_seq;
    create sequence nsl_global_seq minvalue 1000 maxvalue 10000000;

    create table author (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        abbrev varchar(100),
        created_at timestamp with time zone not null,
        created_by varchar(255) not null,
        date_range varchar(50),
        duplicate_of_id int8,
        full_name varchar(255),
        ipni_id varchar(50),
        name varchar(255),
        namespace_id int8 not null,
        notes varchar(1000),
        source_id int8,
        source_id_string varchar(100),
        source_system varchar(50),
        trash boolean default false not null,
        updated_at timestamp with time zone not null,
        updated_by varchar(255) not null,
        valid_record boolean default false not null,
        primary key (id)
    );

    create table comment (
        id int8 default nextval('hibernate_sequence') not null,
        lock_version int8 default 0 not null,
        author_id int8,
        created_at timestamp with time zone not null,
        created_by varchar(50) not null,
        instance_id int8,
        name_id int8,
        reference_id int8,
        text text not null,
        updated_at timestamp with time zone not null,
        updated_by varchar(50) not null,
        primary key (id)
    );

    create table db_version (
        id int8 not null,
        version int4 not null,
        primary key (id)
    );

    create table delayed_jobs (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        attempts numeric(19, 2),
        created_at timestamp with time zone not null,
        failed_at timestamp with time zone,
        handler text,
        last_error text,
        locked_at timestamp with time zone,
        locked_by varchar(4000),
        priority numeric(19, 2),
        queue varchar(4000),
        run_at timestamp with time zone,
        updated_at timestamp with time zone not null,
        primary key (id)
    );

    create table external_ref (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        external_id varchar(50) not null,
        external_id_supplier varchar(50) not null,
        instance_id int8 not null,
        name_id int8 not null,
        object_type varchar(50),
        original_provider numeric(19, 2),
        reference_id int8 not null,
        primary key (id)
    );

    create table help_topic (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        created_at timestamp not null,
        created_by varchar(4000) not null,
        marked_up_text text not null,
        name varchar(4000) not null,
        sort_order int4 default 0 not null,
        trash boolean default false not null,
        updated_at timestamp not null,
        updated_by varchar(4000) not null,
        primary key (id)
    );

    create table id_mapper (
        id int8 not null,
        from_id int8 not null,
        namespace_id int8 not null,
        system varchar(20) not null,
        to_id int8,
        primary key (id)
    );

    create table instance (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        bhl_url varchar(4000),
        cited_by_id int8,
        cites_id int8,
        created_at timestamp with time zone not null,
        created_by varchar(50) not null,
        draft boolean default false not null,
        instance_type_id int8 not null,
        name_id int8 not null,
        namespace_id int8 not null,
        nomenclatural_status varchar(50),
        page varchar(255),
        page_qualifier varchar(255),
        parent_id int8,
        reference_id int8 not null,
        source_id int8,
        source_id_string varchar(100),
        source_system varchar(50),
        trash boolean default false not null,
        updated_at timestamp with time zone not null,
        updated_by varchar(1000) not null,
        valid_record boolean default false not null,
        verbatim_name_string varchar(255),
        primary key (id)
    );

    create table instance_note (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        created_at timestamp with time zone not null,
        created_by varchar(50) not null,
        instance_id int8 not null,
        instance_note_key_id int8 not null,
        namespace_id int8 not null,
        source_id int8,
        source_id_string varchar(100),
        source_system varchar(50),
        trash boolean default false not null,
        updated_at timestamp with time zone not null,
        updated_by varchar(50) not null,
        value varchar(4000) not null,
        primary key (id)
    );

    create table instance_note_key (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        deprecated boolean default false not null,
        description_html text,
        name varchar(255) not null,
        rdf_id varchar(50),
        sort_order int4 default 0 not null,
        primary key (id)
    );

    create table instance_type (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        citing boolean default false not null,
        deprecated boolean default false not null,
        description_html text,
        doubtful boolean default false not null,
        misapplied boolean default false not null,
        name varchar(255) not null,
        nomenclatural boolean default false not null,
        primary_instance boolean default false not null,
        pro_parte boolean default false not null,
        protologue boolean default false not null,
        rdf_id varchar(50),
        relationship boolean default false not null,
        secondary_instance boolean default false not null,
        sort_order int4 default 0 not null,
        standalone boolean default false not null,
        synonym boolean default false not null,
        taxonomic boolean default false not null,
        unsourced boolean default false not null,
        primary key (id)
    );

    create table language (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        iso6391code varchar(2),
        iso6393code varchar(3) not null,
        name varchar(50) not null,
        primary key (id)
    );

    create table locale (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        locale_name_string varchar(50) not null,
        primary key (id)
    );

    create table name (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        author_id int8,
        base_author_id int8,
        created_at timestamp with time zone not null,
        created_by varchar(50) not null,
        duplicate_of_id int8,
        ex_author_id int8,
        ex_base_author_id int8,
        full_name varchar(512),
        full_name_html varchar(2048),
        name_element varchar(255),
        name_rank_id int8 not null,
        name_status_id int8 not null,
        name_type_id int8 not null,
        namespace_id int8 not null,
        orth_var boolean default false not null,
        parent_id int8,
        sanctioning_author_id int8,
        second_parent_id int8,
        simple_name varchar(250),
        simple_name_html varchar(2048),
        source_dup_of_id int8,
        source_id int8,
        source_id_string varchar(100),
        source_system varchar(50),
        status_summary varchar(50),
        trash boolean default false not null,
        updated_at timestamp with time zone not null,
        updated_by varchar(50) not null,
        valid_record boolean default false not null,
        verbatim_rank varchar(50),
        why_is_this_here_id int8,
        primary key (id)
    );

    create table name_category (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        description_html text,
        name varchar(50) not null,
        rdf_id varchar(50),
        sort_order int4 default 0 not null,
        primary key (id)
    );

    create table name_group (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        description_html text,
        name varchar(50),
        rdf_id varchar(50),
        primary key (id)
    );

    create table name_part (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        name_id int8 not null,
        preceding_name_id int8 not null,
        preceding_name_type varchar(50) not null,
        primary key (id)
    );

    create table name_rank (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        abbrev varchar(20) not null,
        deprecated boolean default false not null,
        description_html text,
        has_parent boolean default false not null,
        italicize boolean default false not null,
        major boolean default false not null,
        name varchar(50) not null,
        name_group_id int8 not null,
        parent_rank_id int8,
        rdf_id varchar(50),
        sort_order int4 default 0 not null,
        visible_in_name boolean default true not null,
        primary key (id)
    );

    create table name_status (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        description_html text,
        display boolean default true not null,
        name varchar(50),
        name_group_id int8 not null,
        name_status_id int8,
        nom_illeg boolean default false not null,
        nom_inval boolean default false not null,
        rdf_id varchar(50),
        primary key (id)
    );

    create table name_tag (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        name varchar(255) not null,
        primary key (id)
    );

    create table name_tag_name (
        name_id int8 not null,
        tag_id int8 not null,
        created_at timestamp with time zone not null,
        created_by varchar(255) not null,
        updated_at timestamp with time zone not null,
        updated_by varchar(255) not null,
        primary key (name_id, tag_id)
    );

    create table name_tree_path (
        id int8 not null,
        version int8 not null,
        inserted int8 not null,
        name_id int8 not null,
        next_id int8,
        parent_id int8,
        path varchar(4000) not null,
        tree_id int8 not null,
        tree_path varchar(4000) not null,
        primary key (id)
    );

    create table name_type (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        autonym boolean default false not null,
        connector varchar(1),
        cultivar boolean default false not null,
        deprecated boolean default false not null,
        description_html text,
        formula boolean default false not null,
        hybrid boolean default false not null,
        name varchar(255) not null,
        name_category_id int8 not null,
        name_group_id int8 not null,
        rdf_id varchar(50),
        scientific boolean default false not null,
        sort_order int4 default 0 not null,
        primary key (id)
    );

    create table namespace (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        description_html text,
        name varchar(255) not null,
        rdf_id varchar(50),
        primary key (id)
    );

    create table nomenclatural_event_type (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        description_html text,
        name_group_id int8 not null,
        nomenclatural_event_type varchar(50),
        rdf_id varchar(50),
        primary key (id)
    );

    create table notification (
        id int8 not null,
        version int8 not null,
        message varchar(255) not null,
        object_id int8,
        primary key (id)
    );

    create table nsl_simple_name (
        id int8 not null,
        apc_comment varchar(4000),
        apc_distribution varchar(4000),
        apc_excluded boolean default false not null,
        apc_familia varchar(255),
        apc_instance_id int8,
        apc_name varchar(512),
        apc_proparte boolean default false not null,
        apc_relationship_type varchar(255),
        apni boolean default false,
        author varchar(255),
        authority varchar(255),
        autonym boolean default false,
        base_name_author varchar(255),
        basionym varchar(512),
        classifications varchar(255),
        classis varchar(255),
        created_at timestamp,
        created_by varchar(255),
        cultivar boolean default false not null,
        cultivar_name varchar(255),
        dup_of_id int8,
        ex_author varchar(255),
        ex_base_name_author varchar(255),
        familia varchar(255),
        family_nsl_id int8,
        formula boolean default false not null,
        full_name_html varchar(2048),
        genus varchar(255),
        genus_nsl_id int8,
        homonym boolean default false,
        hybrid boolean default false,
        infraspecies varchar(255),
        name varchar(255) not null,
        name_element varchar(255),
        name_rank_id int8 not null,
        name_status_id int8 not null,
        name_type_id int8 not null,
        name_type_name varchar(255) not null,
        nom_illeg boolean default false,
        nom_inval boolean default false,
        nom_stat varchar(255) not null,
        parent_nsl_id int8,
        proto_citation varchar(512),
        proto_instance_id int8,
        proto_year int2,
        rank varchar(255) not null,
        rank_abbrev varchar(255),
        rank_sort_order int4,
        replaced_synonym varchar(512),
        sanctioning_author varchar(255),
        scientific boolean default false,
        second_parent_nsl_id int8,
        simple_name_html varchar(2048),
        species varchar(255),
        species_nsl_id int8,
        subclassis varchar(255),
        taxon_name varchar(512) not null,
        updated_at timestamp,
        updated_by varchar(255),
        primary key (id)
    );

    create table ref_author_role (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        description_html text,
        name varchar(255) not null,
        rdf_id varchar(50),
        primary key (id)
    );

    create table ref_type (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        description_html text,
        name varchar(50) not null,
        parent_id int8,
        parent_optional boolean default false not null,
        rdf_id varchar(50),
        primary key (id)
    );

    create table reference (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        abbrev_title varchar(2000),
        author_id int8 not null,
        bhl_url varchar(4000),
        citation varchar(512),
        citation_html varchar(512),
        created_at timestamp with time zone not null,
        created_by varchar(255) not null,
        display_title varchar(2000) not null,
        doi varchar(255),
        duplicate_of_id int8,
        edition varchar(50),
        isbn varchar(16),
        issn varchar(16),
        language_id int8 not null,
        namespace_id int8 not null,
        notes varchar(1000),
        pages varchar(100),
        parent_id int8,
        publication_date varchar(50),
        published boolean default false not null,
        published_location varchar(50),
        publisher varchar(100),
        ref_author_role_id int8 not null,
        ref_type_id int8 not null,
        source_id int8,
        source_id_string varchar(100),
        source_system varchar(50),
        title varchar(2000) not null,
        tl2 varchar(30),
        trash boolean default false not null,
        updated_at timestamp with time zone not null,
        updated_by varchar(1000) not null,
        valid_record boolean default false not null,
        verbatim_author varchar(1000),
        verbatim_citation varchar(2000),
        verbatim_reference varchar(1000),
        volume varchar(50),
        year int4,
        primary key (id)
    );

    create table trashed_item (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        created_at timestamp with time zone not null,
        created_by varchar(4000) not null,
        trashable_id numeric(19, 2) not null,
        trashable_type varchar(4000) not null,
        trashing_event_id int8,
        updated_at timestamp with time zone not null,
        updated_by varchar(4000) not null,
        primary key (id)
    );

    create table trashing_event (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        created_at timestamp with time zone not null,
        created_by varchar(4000) not null,
        updated_at timestamp with time zone not null,
        updated_by varchar(4000) not null,
        primary key (id)
    );

    create table tree_arrangement (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        tree_type bpchar not null,
        description varchar(255),
        label varchar(50),
        node_id int8,
        is_synthetic bpchar not null,
        title varchar(50),
        primary key (id)
    );

    create table tree_event (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        auth_user varchar(255) not null,
        note varchar(255),
        time_stamp timestamp with time zone not null,
        primary key (id)
    );

    create table tree_link (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        link_seq int4 not null,
        subnode_id int8 not null,
        supernode_id int8 not null,
        is_synthetic bpchar not null,
        type_uri_id_part varchar(255),
        type_uri_ns_part_id int8 not null,
        versioning_method bpchar not null,
        primary key (id)
    );

    create table tree_node (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        checked_in_at_id int8,
        instance_id int8,
        internal_type varchar(255) not null,
        literal varchar(4096),
        name_id int8,
        name_uri_id_part varchar(255),
        name_uri_ns_part_id int8,
        next_node_id int8,
        prev_node_id int8,
        replaced_at_id int8,
        resource_uri_id_part varchar(255),
        resource_uri_ns_part_id int8,
        tree_arrangement_id int8,
        is_synthetic bpchar not null,
        taxon_uri_id_part varchar(255),
        taxon_uri_ns_part_id int8,
        type_uri_id_part varchar(255),
        type_uri_ns_part_id int8 not null,
        primary key (id)
    );

    create table tree_uri_ns (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        description varchar(255),
        id_mapper_namespace_id int8,
        id_mapper_system varchar(255),
        label varchar(20) not null,
        owner_uri_id_part varchar(255),
        owner_uri_ns_part_id int8,
        title varchar(255),
        uri varchar(255),
        primary key (id)
    );

    create table user_query (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        created_at timestamp with time zone not null,
        query_completed boolean default false not null,
        query_started boolean default false not null,
        record_count numeric(19, 2) not null,
        search_finished_at timestamp with time zone,
        search_info varchar(500),
        search_model varchar(4000),
        search_result text,
        search_started_at timestamp with time zone,
        search_terms varchar(4000),
        trash boolean default false not null,
        updated_at timestamp with time zone not null,
        primary key (id)
    );

    create table why_is_this_here (
        id int8 default nextval('nsl_global_seq') not null,
        lock_version int8 default 0 not null,
        name varchar(50) not null,
        sort_order int4 default 0 not null,
        primary key (id)
    );

    create index Author_Abbrev_Index on author (abbrev);

    create index Author_Name_Index on author (name);

    create index Auth_Source_Index on author (namespace_id, source_id, source_system);

    create index Auth_Source_String_Index on author (source_id_string);

    create index Auth_System_Index on author (source_system);

    create index Comment_author_Index on comment (author_id);

    create index Comment_instance_Index on comment (instance_id);

    create index Comment_name_Index on comment (name_id);

    create index Comment_reference_Index on comment (reference_id);

    alter table if exists id_mapper 
        add constraint unique_from_id  unique (to_id, from_id);

    create index id_mapper_from_Index on id_mapper (from_id, namespace_id, system);

    create index Instance_CitedBy_Index on instance (cited_by_id);

    create index Instance_Cites_Index on instance (cites_id);

    create index Instance_InstanceType_Index on instance (instance_type_id);

    create index Instance_Name_Index on instance (name_id);

    create index Instance_Source_Index on instance (namespace_id, source_id, source_system);

    create index Instance_Parent_Index on instance (parent_id);

    create index Instance_Reference_Index on instance (reference_id);

    create index Instance_Source_String_Index on instance (source_id_string);

    create index Instance_System_Index on instance (source_system);

    create index Note_Instance_Index on instance_note (instance_id);

    create index Note_Key_Index on instance_note (instance_note_key_id);

    create index Note_Source_Index on instance_note (namespace_id, source_id, source_system);

    create index Note_Source_String_Index on instance_note (source_id_string);

    create index Note_System_Index on instance_note (source_system);

    alter table if exists instance_note_key 
        add constraint UK_a0justk7c77bb64o6u1riyrlh  unique (name);

    alter table if exists instance_type 
        add constraint UK_j5337m9qdlirvd49v4h11t1lk  unique (name);

    alter table if exists language 
        add constraint UK_hghw87nl0ho38f166atlpw2hy  unique (iso6391code);

    alter table if exists language 
        add constraint UK_rpsahneqboogcki6p1bpygsua  unique (iso6393code);

    alter table if exists language 
        add constraint UK_g8hr207ijpxlwu10pewyo65gv  unique (name);

    alter table if exists locale 
        add constraint UK_qjkskvl9hx0w78truoyq9teju  unique (locale_name_string);

    create index Name_author_Index on name (author_id);

    create index Name_baseAuthor_Index on name (base_author_id);

    create index Name_exAuthor_Index on name (ex_author_id);

    create index Name_exBaseAuthor_Index on name (ex_base_author_id);

    create index Name_Full_Name_Index on name (full_name);

    create index Name_Name_Element_Index on name (name_element);

    create index Name_Rank_Index on name (name_rank_id);

    create index Name_Status_Index on name (name_status_id);

    create index Name_Type_Index on name (name_type_id);

    create index Name_Source_Index on name (namespace_id, source_id, source_system);

    create index Name_sanctioningAuthor_Index on name (sanctioning_author_id);

    create index Name_Simple_Name_Index on name (simple_name);

    create index Name_Source_String_Index on name (source_id_string);

    create index Name_System_Index on name (source_system);

    create index Name_whyIsThisHere_Index on name (why_is_this_here_id);

    alter table if exists name_category 
        add constraint UK_rxqxoenedjdjyd4x7c98s59io  unique (name);

    alter table if exists name_group 
        add constraint UK_5185nbyw5hkxqyyqgylfn2o6d  unique (name);

    create index preceding_name_type_Index on name_part (preceding_name_type);

    alter table if exists name_status 
        add constraint UK_se7crmfnhjmyvirp3p9hiqerx  unique (name);

    alter table if exists name_tag 
        add constraint UK_o4su6hi7vh0yqs4c1dw0fsf1e  unique (name);

    create index Name_Tag_Name_Index on name_tag_name (name_id);

    create index Name_Tag_Tag_Index on name_tag_name (tag_id);

    create index name_tree_path_name_index on name_tree_path (name_id);

    create index name_tree_path_path_index on name_tree_path (path);

    create index name_tree_path_treepath_index on name_tree_path (tree_path);

    alter table if exists name_type 
        add constraint UK_314uhkq8i7r46050kd1nfrs95  unique (name);

    alter table if exists namespace 
        add constraint UK_eq2y9mghytirkcofquanv5frf  unique (name);

    alter table if exists ref_author_role 
        add constraint UK_l95kedbafybjpp3h53x8o9fke  unique (name);

    alter table if exists ref_type 
        add constraint UK_4fp66uflo7rgx59167ajs0ujv  unique (name);

    alter table if exists reference 
        add constraint UK_kqwpm0crhcq4n9t9uiyfxo2df  unique (doi);

    create index Reference_Author_Index on reference (author_id);

    create index Ref_Source_Index on reference (namespace_id, source_id, source_system);

    create index Reference_Parent_Index on reference (parent_id);

    create index Reference_AuthorRole_Index on reference (ref_author_role_id);

    create index Reference_Type_Index on reference (ref_type_id);

    create index Ref_Source_String_Index on reference (source_id_string);

    create index Ref_System_Index on reference (source_system);

    alter table if exists tree_arrangement 
        add constraint UK_y303qbh1ijdg3sncl9vlxus0  unique (label);

    create index tree_arrangement_label on tree_arrangement (label);

    create index tree_arrangement_node on tree_arrangement (node_id);

    create index tree_link_subnode on tree_link (subnode_id);

    create index tree_link_supernode on tree_link (supernode_id);

    create index idx_tree_node_instance_id on tree_node (instance_id);

    create index idx_tree_node_instance_id_in on tree_node (instance_id, tree_arrangement_id);

    create index idx_tree_node_literal on tree_node (literal);

    create index idx_tree_node_name_id on tree_node (name_id);

    create index idx_tree_node_name_id_in on tree_node (name_id, tree_arrangement_id);

    create index idx_tree_node_name on tree_node (name_uri_id_part, name_uri_ns_part_id);

    create index idx_tree_node_name_in on tree_node (name_uri_id_part, name_uri_ns_part_id, tree_arrangement_id);

    create index tree_node_next on tree_node (next_node_id);

    create index tree_node_prev on tree_node (prev_node_id);

    create index idx_tree_node_resource on tree_node (resource_uri_id_part, resource_uri_ns_part_id);

    create index idx_tree_node_resource_in on tree_node (resource_uri_id_part, resource_uri_ns_part_id, tree_arrangement_id);

    create index idx_tree_node_taxon_in on tree_node (tree_arrangement_id, taxon_uri_id_part, taxon_uri_ns_part_id);

    create index idx_tree_node_taxon on tree_node (taxon_uri_id_part, taxon_uri_ns_part_id);

    alter table if exists tree_uri_ns 
        add constraint UK_5smmen5o34hs50jxd247k81ia  unique (label);

    alter table if exists tree_uri_ns 
        add constraint UK_70p0ys3l5v6s9dqrpjr3u3rrf  unique (uri);

    create index idx_tree_uri_ns_label on tree_uri_ns (label);

    create index idx_tree_uri_ns_uri on tree_uri_ns (uri);

    alter table if exists why_is_this_here 
        add constraint UK_sv1q1i7xve7xgmkwvmdbeo1mb  unique (name);

    alter table if exists author 
        add constraint FK_6a4p11f1bt171w09oo06m0wag 
        foreign key (duplicate_of_id) 
        references author;

    alter table if exists author 
        add constraint FK_p0ysrub11cm08xnhrbrfrvudh 
        foreign key (namespace_id) 
        references namespace;

    alter table if exists comment 
        add constraint FK_9aq5p2jgf17y6b38x5ayd90oc 
        foreign key (author_id) 
        references author;

    alter table if exists comment 
        add constraint FK_6oqj6vquqc33cyawn853hfu5g 
        foreign key (instance_id) 
        references instance;

    alter table if exists comment 
        add constraint FK_h9t5eaaqhnqwrc92rhryyvdcf 
        foreign key (name_id) 
        references name;

    alter table if exists comment 
        add constraint FK_3tfkdcmf6rg6hcyiu8t05er7x 
        foreign key (reference_id) 
        references reference;

    alter table if exists external_ref 
        add constraint FK_4g2i2qry4941xmqijgeo8ns2h 
        foreign key (instance_id) 
        references instance;

    alter table if exists external_ref 
        add constraint FK_bu7q5itmt7w7q1bex049xvac7 
        foreign key (name_id) 
        references name;

    alter table if exists external_ref 
        add constraint FK_f7igpcpvgcmdfb7v3bgjluqsf 
        foreign key (reference_id) 
        references reference;

    alter table if exists id_mapper 
        add constraint FK_qiy281xsleyhjgr0eu1sboagm 
        foreign key (namespace_id) 
        references namespace;

    alter table if exists instance 
        add constraint FK_pr2f6peqhnx9rjiwkr5jgc5be 
        foreign key (cited_by_id) 
        references instance;

    alter table if exists instance 
        add constraint FK_30enb6qoexhuk479t75apeuu5 
        foreign key (cites_id) 
        references instance;

    alter table if exists instance 
        add constraint FK_o80rrtl8xwy4l3kqrt9qv0mnt 
        foreign key (instance_type_id) 
        references instance_type;

    alter table if exists instance 
        add constraint FK_gdunt8xo68ct1vfec9c6x5889 
        foreign key (name_id) 
        references name;

    alter table if exists instance 
        add constraint FK_gtkjmbvk6uk34fbfpy910e7t6 
        foreign key (namespace_id) 
        references namespace;

    alter table if exists instance 
        add constraint FK_hb0xb97midopfgrm2k5fpe3p1 
        foreign key (parent_id) 
        references instance;

    alter table if exists instance 
        add constraint FK_lumlr5avj305pmc4hkjwaqk45 
        foreign key (reference_id) 
        references reference;

    alter table if exists instance_note 
        add constraint FK_bw41122jb5rcu8wfnog812s97 
        foreign key (instance_id) 
        references instance;

    alter table if exists instance_note 
        add constraint FK_he1t3ug0o7ollnk2jbqaouooa 
        foreign key (instance_note_key_id) 
        references instance_note_key;

    alter table if exists instance_note 
        add constraint FK_f6s94njexmutjxjv8t5dy1ugt 
        foreign key (namespace_id) 
        references namespace;

    alter table if exists name 
        add constraint FK_airfjupm6ohehj1lj82yqkwdx 
        foreign key (author_id) 
        references author;

    alter table if exists name 
        add constraint FK_coqxx3ewgiecsh3t78yc70b35 
        foreign key (base_author_id) 
        references author;

    alter table if exists name 
        add constraint FK_3pqdqa03w5c6h4yyrrvfuagos 
        foreign key (duplicate_of_id) 
        references name;

    alter table if exists name 
        add constraint FK_sgvxmyj7r9g4wy9c4hd1yn4nu 
        foreign key (ex_author_id) 
        references author;

    alter table if exists name 
        add constraint FK_rp659tjcxokf26j8551k6an2y 
        foreign key (ex_base_author_id) 
        references author;

    alter table if exists name 
        add constraint FK_sk2iikq8wla58jeypkw6h74hc 
        foreign key (name_rank_id) 
        references name_rank;

    alter table if exists name 
        add constraint FK_5fpm5u0ukiml9nvmq14bd7u51 
        foreign key (name_status_id) 
        references name_status;

    alter table if exists name 
        add constraint FK_bcef76k0ijrcquyoc0yxehxfp 
        foreign key (name_type_id) 
        references name_type;

    alter table if exists name 
        add constraint FK_156ncmx4599jcsmhh5k267cjv 
        foreign key (namespace_id) 
        references namespace;

    alter table if exists name 
        add constraint FK_dd33etb69v5w5iah1eeisy7yt 
        foreign key (parent_id) 
        references name;

    alter table if exists name 
        add constraint FK_ai81l07vh2yhmthr3582igo47 
        foreign key (sanctioning_author_id) 
        references author;

    alter table if exists name 
        add constraint FK_5gp2lfblqq94c4ud3340iml0l 
        foreign key (second_parent_id) 
        references name;

    alter table if exists name 
        add constraint FK_dqhn53mdh0n77xhsw7l5dgd38 
        foreign key (why_is_this_here_id) 
        references why_is_this_here;

    alter table if exists name_part 
        add constraint FK_s13ituehdpf6uh859umme7g1j 
        foreign key (name_id) 
        references name;

    alter table if exists name_part 
        add constraint FK_pj38oewhgjq8rp08fc9cviteu 
        foreign key (preceding_name_id) 
        references name;

    alter table if exists name_rank 
        add constraint FK_p3lpayfbl9s3hshhoycfj82b9 
        foreign key (name_group_id) 
        references name_group;

    alter table if exists name_rank 
        add constraint FK_r67um91pujyfrx7h1cifs3cmb 
        foreign key (parent_rank_id) 
        references name_rank;

    alter table if exists name_status 
        add constraint FK_swotu3c2gy1hp8f6ekvuo7s26 
        foreign key (name_group_id) 
        references name_group;

    alter table if exists name_status 
        add constraint FK_g4o6xditli5a0xrm6eqc6h9gw 
        foreign key (name_status_id) 
        references name_status;

    alter table if exists name_tag_name 
        add constraint FK_22wdc2pxaskytkgpdgpyok07n 
        foreign key (name_id) 
        references name;

    alter table if exists name_tag_name 
        add constraint FK_2uiijd73snf6lh5s6a82yjfin 
        foreign key (tag_id) 
        references name_tag;

    alter table if exists name_tree_path 
        add constraint FK_j4j0kq9duod9gm019pl1xec7c 
        foreign key (name_id) 
        references name;

    alter table if exists name_tree_path 
        add constraint FK_try5dwb6jcy5fngk09bf7f7on 
        foreign key (next_id) 
        references name_tree_path;

    alter table if exists name_tree_path 
        add constraint FK_sfj3hoevcuni3ak7no6byjp3 
        foreign key (parent_id) 
        references name_tree_path;

    alter table if exists name_tree_path 
        add constraint FK_3xnmxe5p6ed258euacrfflwrj 
        foreign key (tree_id) 
        references tree_arrangement;

    alter table if exists name_type 
        add constraint FK_10d0jlulq2woht49j5ccpeehu 
        foreign key (name_category_id) 
        references name_category;

    alter table if exists name_type 
        add constraint FK_5r3o78sgdbxsf525hmm3t44gv 
        foreign key (name_group_id) 
        references name_group;

    alter table if exists nomenclatural_event_type 
        add constraint FK_ql5g85814a9y57c1ifd0nkq3v 
        foreign key (name_group_id) 
        references name_group;

    alter table if exists nsl_simple_name 
        add constraint FK_lgtnu32ysbg6l2ys5d6bhfgmq 
        foreign key (apc_instance_id) 
        references instance;

    alter table if exists nsl_simple_name 
        add constraint FK_on28vygd1e7aqn9owbhv3u23h 
        foreign key (family_nsl_id) 
        references name;

    alter table if exists nsl_simple_name 
        add constraint FK_ctg301hhg3x41rjl09d7noti1 
        foreign key (genus_nsl_id) 
        references name;

    alter table if exists nsl_simple_name 
        add constraint FK_k4ryd8xarm9hhk1aitqtfg0tb 
        foreign key (name_rank_id) 
        references name_rank;

    alter table if exists nsl_simple_name 
        add constraint FK_bexlla3pvlm2x8err16puv16f 
        foreign key (name_status_id) 
        references name_status;

    alter table if exists nsl_simple_name 
        add constraint FK_gbcxpwubk8cdlh5fxnd3ln4up 
        foreign key (name_type_id) 
        references name_type;

    alter table if exists nsl_simple_name 
        add constraint FK_kquvd2hkcl7aj2vhylvp1k7vb 
        foreign key (parent_nsl_id) 
        references name;

    alter table if exists nsl_simple_name 
        add constraint FK_59i6is32bt6v19i51ql9n2r9i 
        foreign key (proto_instance_id) 
        references instance;

    alter table if exists nsl_simple_name 
        add constraint FK_mvjeehgt584v9ep11ixe1iyok 
        foreign key (second_parent_nsl_id) 
        references name;

    alter table if exists nsl_simple_name 
        add constraint FK_rpqdbhi21sdix5tmmj5ul61su 
        foreign key (species_nsl_id) 
        references name;

    alter table if exists ref_type 
        add constraint FK_51alfoe7eobwh60yfx45y22ay 
        foreign key (parent_id) 
        references ref_type;

    alter table if exists reference 
        add constraint FK_p8lhsoo01164dsvvwxob0w3sp 
        foreign key (author_id) 
        references author;

    alter table if exists reference 
        add constraint FK_3min66ljijxavb0fjergx5dpm 
        foreign key (duplicate_of_id) 
        references reference;

    alter table if exists reference 
        add constraint FK_1qx84m8tuk7vw2diyxfbj5r2n 
        foreign key (language_id) 
        references language;

    alter table if exists reference 
        add constraint FK_am2j11kvuwl19gqewuu18gjjm 
        foreign key (namespace_id) 
        references namespace;

    alter table if exists reference 
        add constraint FK_cr9avt4miqikx4kk53aflnnkd 
        foreign key (parent_id) 
        references reference;

    alter table if exists reference 
        add constraint FK_a98ei1lxn89madjihel3cvi90 
        foreign key (ref_author_role_id) 
        references ref_author_role;

    alter table if exists reference 
        add constraint FK_dm9y4p9xpsc8m7vljbohubl7x 
        foreign key (ref_type_id) 
        references ref_type;

    alter table if exists trashed_item 
        add constraint FK_bd6arfjuj28nolsc58i345ybg 
        foreign key (trashing_event_id) 
        references trashing_event;

    alter table if exists tree_arrangement 
        add constraint FK_fvfq13j3dqv994o9vg54yj5kk 
        foreign key (node_id) 
        references tree_node;

    alter table if exists tree_link 
        add constraint FK_tgankaahxgr4p0mw4opafah05 
        foreign key (subnode_id) 
        references tree_node;

    alter table if exists tree_link 
        add constraint FK_kqshktm171nwvk38ot4d12w6b 
        foreign key (supernode_id) 
        references tree_node;

    alter table if exists tree_link 
        add constraint FK_2dk33tolvn16lfmp25nk2584y 
        foreign key (type_uri_ns_part_id) 
        references tree_uri_ns;

    alter table if exists tree_node 
        add constraint FK_nlq0qddnhgx65iojhj2xm8tay 
        foreign key (checked_in_at_id) 
        references tree_event;

    alter table if exists tree_node 
        add constraint FK_1g9477sa8plad5cxkxmiuh5b 
        foreign key (instance_id) 
        references instance;

    alter table if exists tree_node 
        add constraint FK_eqw4xo7vty6e4tq8hy34c51om 
        foreign key (name_id) 
        references name;

    alter table if exists tree_node 
        add constraint FK_gc6f9ykh7eaflvty9tr6n4cb6 
        foreign key (name_uri_ns_part_id) 
        references tree_uri_ns;

    alter table if exists tree_node 
        add constraint FK_sbuntfo4jfai44yjh9o09vu6s 
        foreign key (next_node_id) 
        references tree_node;

    alter table if exists tree_node 
        add constraint FK_budb70h51jhcxe7qbtpea0hi2 
        foreign key (prev_node_id) 
        references tree_node;

    alter table if exists tree_node 
        add constraint FK_pc0tkp9bgp1cxull530y60v46 
        foreign key (replaced_at_id) 
        references tree_event;

    alter table if exists tree_node 
        add constraint FK_4y1qy9beekbv71e9i6hto6hun 
        foreign key (resource_uri_ns_part_id) 
        references tree_uri_ns;

    alter table if exists tree_node 
        add constraint FK_t6kkvm8ubsiw6fqg473j0gjga 
        foreign key (tree_arrangement_id) 
        references tree_arrangement;

    alter table if exists tree_node 
        add constraint FK_16c4wgya68bwotwn6f50dhw69 
        foreign key (taxon_uri_ns_part_id) 
        references tree_uri_ns;

    alter table if exists tree_node 
        add constraint FK_oge4ibjd3ff3oyshexl6set2u 
        foreign key (type_uri_ns_part_id) 
        references tree_uri_ns;

    alter table if exists tree_uri_ns 
        add constraint FK_q9k8he941kvl07j2htmqxq35v 
        foreign key (owner_uri_ns_part_id) 
        references tree_uri_ns;

    create sequence hibernate_sequence;

    
-- 
-- This script sets up the base data for the boatree app. This includes the 'end' tree, out in-house namespaces, and the empty nsl/apc/afd trees
--

delete from tree_link;
update tree_arrangement set node_id = null;
delete from tree_node;
delete from tree_arrangement;
delete from tree_event;
delete from tree_uri_ns;


-- THESE IDS ARE SYSTEM-WIDE CONSTANTS. THEY MAY APPEAR AS MAGIC NUMBERS IN CODE.
-- LABELS ARE ALSO MAGIC NUMBERS, USUALLY FETCHED BY THE tree_get_ns_id() FUNCTION.
-- It's 12:03 AM, and the labels I pick right now are what we are stuck with forever. I'll make 'em short.

-- I use ID zero because the 'no namespace' namespace is a null object. Its purpose is so that we don't have to outer join
-- every time we write a query that (for instance) constructs the taxon_uri for a node
-- we include this explicitly so that we dont have to outer join all over the shop.

insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	0, 1,
	'', 
	'none', 'no namespace',
	'No namespace - the ID contains the full URI.',
	0, null,
	null, null
);

-- we include this exoplicitly so that the null tree and node URI reliably have ids (1,0)
insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	1, 1,
	'http://biodiversity.org.au/voc/boatree/BOATREE#', 
	'boatree-voc',
	'BOATREE',
	'Top level BOATREE vocabulary.',
	0, 'http://biodiversity.org.au/voc/boatree/BOATREE',
	null, null
);

insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	nextval('nsl_global_seq'), 1, 
	'http://biodiversity.org.au/boatree/voc/', 
	'voc', 'voc namespace',
	'Namespace of the vocabularies served by this instance.',
	0, null,
	null, null
);

update tree_uri_ns
set owner_uri_ns_part_id = (select id from tree_uri_ns where label = 'voc'),
	owner_uri_id_part = 'voc'
where label = 'voc';

insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	nextval('nsl_global_seq'), 1, 
	'http://biodiversity.org.au/boatree/voc/ns#', 
	'ns', 'uri_ns namespace',
	'Namespace of the uri namespaces.',
	(select id from tree_uri_ns where label = 'voc'), 'ns',
	null, null
);

insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	nextval('nsl_global_seq'), 1, 
	'http://biodiversity.org.au/boatree/classification/', 
	'clsf', 'classification namespace',
	'Namespace for top-level public trees, by text identifier.',
	(select id from tree_uri_ns where label = 'voc'), 'classification',
	null, null
);

insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	nextval('nsl_global_seq'), 1, 
	'http://biodiversity.org.au/boatree/arrangement/', 
	'arr', 'arrangement namespace',
	'Namespace for all arrangemnts, by physical id.',
	0, null,
	null, null
);

insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	nextval('nsl_global_seq'), 1, 
	'http://biodiversity.org.au/boatree/node/', 
	'node', 'arrangement node namespace',
	'Namespace for arrangement nodes.',
	0, null,
	null, null
);

insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	nextval('nsl_global_seq'), 1, 
	'http://www.w3.org/2001/XMLSchema#', 
	'xs', 'XML Schema',
	'Base datatypes.',
	0, 'http://www.w3.org/1999/02/22-rdf-syntax-ns',
	null, null
);

insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	nextval('nsl_global_seq'), 1, 
	'http://www.w3.org/1999/02/22-rdf-syntax-ns#', 
	'rdf', 'rdf namespace',
	'Namespace for rdf.',
	0, 'http://www.w3.org/1999/02/22-rdf-syntax-ns',
	null, null
);

insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	nextval('nsl_global_seq'), 1, 
	'http://www.w3.org/2000/01/rdf-schema#', 
	'rdfs', 'rdf schema namespace',
	'Namespace for rdf schema.',
	0, 'http://www.w3.org/2000/01/rdf-schema',
	null, null
);

insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	nextval('nsl_global_seq'), 1, 
	'http://purl.org/dc/elements/1.1/', 
	'dc', 'dublin core',
	'Namespace for Dublin Core.',
	0, 'http://purl.org/dc/elements/1.1',
	null, null
);

insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	nextval('nsl_global_seq'), 1, 
	'http://purl.org/dc/terms/', 
	'dcterms', 'dublin core terms',
	'Namespace for Dublin Core terms.',
	0, 'http://purl.org/dc/terms',
	null, null
);

insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	nextval('nsl_global_seq'), 1, 
	'http://www.w3.org/2002/07/owl#', 
	'owl', 'Web Ontology Language',
	'Namespace for Web Ontology Language (OWL).',
	0, 'http://www.w3.org/2002/07/owl',
	null, null
);

-- not sure about these. Is Greg's stuff keeping the apni ids? Do we need a new namespace for
-- APC names/taxa?

insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	nextval('nsl_global_seq'), 1, 
	'http://biodiversity.org.au/apni.name/', 
	'apni-name', 'APNI name', 
	'An APNI name.',
	0, null,
	1, 'PLANT_NAME'
);

insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	nextval('nsl_global_seq'), 1, 
	'http://biodiversity.org.au/apni.taxon/', 
	'apni-taxon', 'APNI taxon',
	'An APNI taxon.',
	0, null,
	null, null
);

insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	nextval('nsl_global_seq'), 1, 
	'http://biodiversity.org.au/afd.name/', 
	'afd-name', 'AFD name', 
	'An AFD name.',
	0, null,
	null, null
);

insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	nextval('nsl_global_seq'), 1, 
	'http://biodiversity.org.au/afd.taxon/', 
	'afd-taxon', 'AFD taxon',
	'An AFD taxon.',
	0, null,
	null, null
);

insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	nextval('nsl_global_seq'), 1, 
	'http://biodiversity.org.au/nsl.name/', 
	'nsl-name', 'NSL name',
	'An NSL name.',
	0, null,
	null, null
);

insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	nextval('nsl_global_seq'), 1, 
	'http://biodiversity.org.au/nsl.instance/', 
	'nsl-instance', 'NSL instance',
	'An NSL instance.',
	0, null,
	null, null
);

insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	nextval('nsl_global_seq'), 1, 
	'http://biodiversity.org.au/voc/apc/APC#', 
	'apc-voc', 'APC vocabulary',
	'Vocabulary terms relating specifically to the APC tree.',
	0, null,
	null, null
);

insert into tree_uri_ns(id,lock_version,uri,label,title,description,owner_uri_ns_part_id,owner_uri_id_part,id_mapper_namespace_id,id_mapper_system) values (
	nextval('nsl_global_seq'), 1, 
	'http://biodiversity.org.au/voc/apc/concept/', 
	'apc-concept', 'APC placement',
	'APC_CONCEPT.APC_ID from APNI.',
	0, null,
	null, null
);

-- create the end node. global across all graphs that make use of this structure and ontology
-- the physical id of the end tree and the node are both zero.
-- THIS IS A  MAGIC NUMBER AND MAY APPEAR IN CODE.

-- the end node is a null object. It means "this node has been replaced and is no longer current, but is has not been replaced by anything".
-- If I did not have an end node, then I would have to keep a "status" field on the node table - I'd be spreading the info over two fields, two
-- rdf and json properties, and creating a situation where inconsistent data becomes possible.

insert into tree_arrangement(id, lock_version, tree_type, is_synthetic, label, description) 
values (0, 1, 'E', 'N', 'END-TREE', 'The END tree. This tree is the same abstract object across all instances of this data structure.');

insert into tree_node(id, internal_type, lock_version, is_synthetic, tree_arrangement_id, type_uri_ns_part_id, type_uri_id_part) 
values (0, 'S', 1, 'N', 0, 1, 'EndNode');

update tree_arrangement set node_id = 0;

-- create TMP tree (used for testing, dev)

insert into tree_arrangement(id, lock_version, tree_type, is_synthetic, label, description) 
values (nextval('nsl_global_seq'), 1, 'P', 'N', 'TMP','Temp classification for testing forms');

insert into tree_node(id, internal_type, lock_version, is_synthetic, tree_arrangement_id, type_uri_ns_part_id, type_uri_id_part) 
values (
	nextval('nsl_global_seq'), 'S', 1, 'N',
	(select id from tree_arrangement where tree_type = 'P' and label = 'TMP'),
	(select id from tree_uri_ns where label='boatree-voc'), 'classification-node'
);

update tree_arrangement set node_id = currval('nsl_global_seq') 
where tree_type = 'P' and label = 'TMP';

insert into tree_node(id, internal_type, lock_version, is_synthetic, tree_arrangement_id, type_uri_ns_part_id, type_uri_id_part) 
values (
	nextval('nsl_global_seq'), 'T', 1, 'N',
	(select id from tree_arrangement where tree_type = 'P' and label = 'TMP'),
	(select id from tree_uri_ns where label='boatree-voc'), 'classification-root'
);

-- link all classification root nodes to the classifictaion node nodes. Note that the classifications created above (AFD, NSL, APC, TMP)
-- are not complete until this step is done.

insert into tree_link(id, lock_version, is_synthetic, supernode_id, subnode_id,  type_uri_ns_part_id, type_uri_id_part, versioning_method, link_seq)
select
	nextval('nsl_global_seq'), 1, 'N',
	t.node_id, r_node.id,
	(select id from tree_uri_ns where label='boatree-voc'), 'classification-root-link',
	'T', 1
from tree_arrangement t, tree_node r_node
where
t.id = r_node.tree_arrangement_id
and r_node.type_uri_id_part = 'classification-root';

-- finally, create a tree event for this current load and set it as the event for the various setup operations
-- that we have just done
-- I will use 'NSL-SCHEMA' as the username for now

-- zero event for the creation of the end node and tree

insert into tree_event (id, lock_version, time_stamp, auth_user, note)
values (0, 1, now(), 'NSL SCHEMA', 'Event zero - construction of end node');

update tree_node set checked_in_at_id = 0 where id = 0;

-- event for the creation of the site-specific AFD, APC, NSL and TMP trees

insert into tree_event (id, lock_version, time_stamp, auth_user, note)
values (nextval('nsl_global_seq'), 1, now(), 'NSL SCHEMA', 'Initial trees');

update tree_node set checked_in_at_id = currval('nsl_global_seq') where id <> 0;

commit;
CREATE OR REPLACE FUNCTION name_notification()
  RETURNS TRIGGER AS $name_note$
BEGIN
  IF (TG_OP = 'DELETE')
  THEN
    INSERT INTO notification (id, version, message, object_id)
      SELECT
        nextval('hibernate_sequence'),
        0,
        'name deleted',
        OLD.id;
    RETURN OLD;
  ELSIF (TG_OP = 'UPDATE')
    THEN
      INSERT INTO notification (id, version, message, object_id)
        SELECT
          nextval('hibernate_sequence'),
          0,
          'name updated',
          NEW.id;
      RETURN NEW;
  ELSIF (TG_OP = 'INSERT')
    THEN
      INSERT INTO notification (id, version, message, object_id)
        SELECT
          nextval('hibernate_sequence'),
          0,
          'name created',
          NEW.id;
      RETURN NEW;
  END IF;
  RETURN NULL;
END;
$name_note$ LANGUAGE plpgsql;


CREATE TRIGGER name_update
AFTER INSERT OR UPDATE OR DELETE ON name
FOR EACH ROW
EXECUTE PROCEDURE name_notification();

CREATE OR REPLACE FUNCTION author_notification()
  RETURNS TRIGGER AS $author_note$
BEGIN
  IF (TG_OP = 'DELETE')
  THEN
    INSERT INTO notification (id, version, message, object_id)
      SELECT
        nextval('hibernate_sequence'),
        0,
        'author deleted',
        OLD.id;
    RETURN OLD;
  ELSIF (TG_OP = 'UPDATE')
    THEN
      INSERT INTO notification (id, version, message, object_id)
        SELECT
          nextval('hibernate_sequence'),
          0,
          'author updated',
          NEW.id;
      RETURN NEW;
  ELSIF (TG_OP = 'INSERT')
    THEN
      INSERT INTO notification (id, version, message, object_id)
        SELECT
          nextval('hibernate_sequence'),
          0,
          'author created',
          NEW.id;
      RETURN NEW;
  END IF;
  RETURN NULL;
END;
$author_note$ LANGUAGE plpgsql;


CREATE TRIGGER author_update
AFTER INSERT OR UPDATE OR DELETE ON author
FOR EACH ROW
EXECUTE PROCEDURE author_notification();
-- 
-- this script assumes that we are using POSTGRES
-- 

-- Namespace

-- Event


-- Arrangement

alter table tree_arrangement add constraint chk_tree_arrangement_type check (tree_type IN ('E','P','U','Z'));

alter table tree_arrangement add constraint chk_classification_has_label check (
	tree_type not in ('E', 'P')
	or (
		label is not null
	)
);

-- Node

alter table tree_node add constraint chk_arrangement_synthetic_yn check (is_synthetic IN ('N','Y'));
alter table tree_node add constraint chk_internal_type_enum check (internal_type IN ('S','Z','T','D','V'));

alter table tree_node add constraint chk_internal_type_S check ( 
  	internal_type <> 'S'
  	or (
	  		name_uri_ns_part_id is null 
	  	and taxon_uri_ns_part_id is null 
	  	and resource_uri_ns_part_id is null
	  	and literal is null
  	)
);

alter table tree_node add constraint chk_internal_type_T check ( 
  	internal_type <> 'T'
  	or (
	  	literal is null
  	)
);

alter table tree_node add constraint chk_internal_type_D check ( 
  	internal_type <> 'D'
  	or (
	  		name_uri_ns_part_id is null 
	  	and taxon_uri_ns_part_id is null 
	  	and literal is null
  	)
);

alter table tree_node add constraint chk_internal_type_V check ( 
  	internal_type <> 'V'
  	or (
	  		name_uri_ns_part_id is null 
	  	and taxon_uri_ns_part_id is null 
	  	and (
	  		(resource_uri_ns_part_id is not null and literal is null)
	  		or
	  		(resource_uri_ns_part_id is null and literal is not null)
	  	)
  	)
);

alter table tree_node add constraint chk_tree_node_synthetic_yn check (is_synthetic IN ('N','Y'));

alter table tree_node add constraint chk_tree_node_name_matches check (name_id is null or cast(name_id as varchar)=name_uri_id_part);

alter table tree_node add constraint chk_tree_node_instance_matches check (instance_id is null or cast(instance_id as varchar)=taxon_uri_id_part);

-- Link

-- a node may only have one link for each link_seq number
create unique index idx_tree_link_seq on tree_link(supernode_id, link_seq);
alter table tree_link add constraint chk_tree_link_seq_positive CHECK (link_seq >= 1);
alter table tree_link add constraint chk_tree_link_vmethod CHECK (versioning_method IN ('F','V','T'));
alter table tree_link add constraint chk_tree_link_synthetic_yn CHECK (is_synthetic IN ('N','Y'));
alter table tree_link add constraint chk_tree_link_sup_not_end  check (supernode_id <> 0);
alter table tree_link add constraint chk_tree_link_sub_not_end  check (subnode_id <> 0);

-- grant to the web user as required
GRANT SELECT, INSERT, UPDATE, DELETE ON tree_arrangement TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON tree_link TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON tree_node TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON tree_uri_ns TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON name_tree_path TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON id_mapper TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON author TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON delayed_jobs TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON external_ref TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON help_topic TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON instance TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON instance_type TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON instance_note TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON instance_note_key TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON language TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON locale TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON name TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON name_category TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON name_group TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON name_part TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON name_rank TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON name_status TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON name_type TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON namespace TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON nomenclatural_event_type TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON ref_author_role TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON ref_type TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON reference TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON trashed_item TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON trashing_event TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON user_query TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON nsl_simple_name TO web;
GRANT SELECT, INSERT, UPDATE, DELETE ON notification TO web;
GRANT INSERT, UPDATE, DELETE, SELECT ON name_tag TO web;
GRANT INSERT, UPDATE, DELETE, SELECT ON name_tag_name TO web;
GRANT SELECT, UPDATE ON nsl_global_seq TO web;
GRANT SELECT, UPDATE ON hibernate_sequence TO web;

GRANT SELECT ON tree_arrangement TO read_only;
GRANT SELECT ON tree_link TO read_only;
GRANT SELECT ON tree_node TO read_only;
GRANT SELECT ON tree_uri_ns TO read_only;
GRANT SELECT ON name_tree_path TO read_only;
GRANT SELECT ON id_mapper TO read_only;
GRANT SELECT ON author TO read_only;
GRANT SELECT ON delayed_jobs TO read_only;
GRANT SELECT ON external_ref TO read_only;
GRANT SELECT ON help_topic TO read_only;
GRANT SELECT ON instance TO read_only;
GRANT SELECT ON instance_type TO read_only;
GRANT SELECT ON instance_note TO read_only;
GRANT SELECT ON instance_note_key TO read_only;
GRANT SELECT ON language TO read_only;
GRANT SELECT ON locale TO read_only;
GRANT SELECT ON name TO read_only;
GRANT SELECT ON name_category TO read_only;
GRANT SELECT ON name_group TO read_only;
GRANT SELECT ON name_part TO read_only;
GRANT SELECT ON name_rank TO read_only;
GRANT SELECT ON name_status TO read_only;
GRANT SELECT ON name_type TO read_only;
GRANT SELECT ON namespace TO read_only;
GRANT SELECT ON nomenclatural_event_type TO read_only;
GRANT SELECT ON ref_author_role TO read_only;
GRANT SELECT ON ref_type TO read_only;
GRANT SELECT ON reference TO read_only;
GRANT SELECT ON trashed_item TO read_only;
GRANT SELECT ON trashing_event TO read_only;
GRANT SELECT ON user_query TO read_only;
GRANT SELECT ON nsl_simple_name TO read_only;
GRANT SELECT ON notification TO read_only;
GRANT INSERT ON name_tag TO read_only;
GRANT INSERT ON name_tag_name TO read_only;
-- An audit history is important on most tables. Provide an audit trigger that logs to
-- a dedicated audit table for the major relations.
--
-- This file should be generic and not depend on application roles or structures,
-- as it's being listed here:
--
--    https://wiki.postgresql.org/wiki/Audit_trigger_91plus
--
-- This trigger was originally based on
--   http://wiki.postgresql.org/wiki/Audit_trigger
-- but has been completely rewritten.
--
-- Should really be converted into a relocatable EXTENSION, with control and upgrade files.

CREATE EXTENSION IF NOT EXISTS hstore;

CREATE SCHEMA if NOT EXISTS audit;

drop table if exists audit.logged_actions cascade;

REVOKE ALL ON SCHEMA audit FROM public;

COMMENT ON SCHEMA audit IS 'Out-of-table audit/history logging tables and trigger functions';

--
-- Audited data. Lots of information is available, it's just a matter of how much
-- you really want to record. See:
--
--   http://www.postgresql.org/docs/9.1/static/functions-info.html
--
-- Remember, every column you add takes up more audit table space and slows audit
-- inserts.
--
-- Every index you add has a big impact too, so avoid adding indexes to the
-- audit table unless you REALLY need them. The hstore GIST indexes are
-- particularly expensive.
--
-- It is sometimes worth copying the audit table, or a coarse subset of it that
-- you're interested in, into a temporary table where you CREATE any useful
-- indexes and do your analysis.
--
CREATE TABLE audit.logged_actions (
  event_id bigserial primary key,
  schema_name text not null,
  table_name text not null,
  relid oid not null,
  session_user_name text,
  action_tstamp_tx TIMESTAMP WITH TIME ZONE NOT NULL,
  action_tstamp_stm TIMESTAMP WITH TIME ZONE NOT NULL,
  action_tstamp_clk TIMESTAMP WITH TIME ZONE NOT NULL,
  transaction_id bigint,
  application_name text,
  client_addr inet,
  client_port integer,
  client_query text,
  action TEXT NOT NULL CHECK (action IN ('I','D','U', 'T')),
  row_data hstore,
  changed_fields hstore,
  statement_only boolean not null
);

REVOKE ALL ON audit.logged_actions FROM public;

COMMENT ON TABLE audit.logged_actions IS 'History of auditable actions on audited tables, from audit.if_modified_func()';
COMMENT ON COLUMN audit.logged_actions.event_id IS 'Unique identifier for each auditable event';
COMMENT ON COLUMN audit.logged_actions.schema_name IS 'Database schema audited table for this event is in';
COMMENT ON COLUMN audit.logged_actions.table_name IS 'Non-schema-qualified table name of table event occured in';
COMMENT ON COLUMN audit.logged_actions.relid IS 'Table OID. Changes with drop/create. Get with ''tablename''::regclass';
COMMENT ON COLUMN audit.logged_actions.session_user_name IS 'Login / session user whose statement caused the audited event';
COMMENT ON COLUMN audit.logged_actions.action_tstamp_tx IS 'Transaction start timestamp for tx in which audited event occurred';
COMMENT ON COLUMN audit.logged_actions.action_tstamp_stm IS 'Statement start timestamp for tx in which audited event occurred';
COMMENT ON COLUMN audit.logged_actions.action_tstamp_clk IS 'Wall clock time at which audited event''s trigger call occurred';
COMMENT ON COLUMN audit.logged_actions.transaction_id IS 'Identifier of transaction that made the change. May wrap, but unique paired with action_tstamp_tx.';
COMMENT ON COLUMN audit.logged_actions.client_addr IS 'IP address of client that issued query. Null for unix domain socket.';
COMMENT ON COLUMN audit.logged_actions.client_port IS 'Remote peer IP port address of client that issued query. Undefined for unix socket.';
COMMENT ON COLUMN audit.logged_actions.client_query IS 'Top-level query that caused this auditable event. May be more than one statement.';
COMMENT ON COLUMN audit.logged_actions.application_name IS 'Application name set when this audit event occurred. Can be changed in-session by client.';
COMMENT ON COLUMN audit.logged_actions.action IS 'Action type; I = insert, D = delete, U = update, T = truncate';
COMMENT ON COLUMN audit.logged_actions.row_data IS 'Record value. Null for statement-level trigger. For INSERT this is the new tuple. For DELETE and UPDATE it is the old tuple.';
COMMENT ON COLUMN audit.logged_actions.changed_fields IS 'New values of fields changed by UPDATE. Null except for row-level UPDATE events.';
COMMENT ON COLUMN audit.logged_actions.statement_only IS '''t'' if audit event is from an FOR EACH STATEMENT trigger, ''f'' for FOR EACH ROW';

CREATE INDEX logged_actions_relid_idx ON audit.logged_actions(relid);
CREATE INDEX logged_actions_action_tstamp_tx_stm_idx ON audit.logged_actions(action_tstamp_stm);
CREATE INDEX logged_actions_action_idx ON audit.logged_actions(action);

CREATE OR REPLACE FUNCTION audit.if_modified_func() RETURNS TRIGGER AS $body$
DECLARE
    audit_row audit.logged_actions;
    include_values boolean;
    log_diffs boolean;
    h_old hstore;
    h_new hstore;
    excluded_cols text[] = ARRAY[]::text[];
BEGIN
    IF TG_WHEN <> 'AFTER' THEN
        RAISE EXCEPTION 'audit.if_modified_func() may only run as an AFTER trigger';
    END IF;

    audit_row = ROW(
        nextval('audit.logged_actions_event_id_seq'), -- event_id
        TG_TABLE_SCHEMA::text,                        -- schema_name
        TG_TABLE_NAME::text,                          -- table_name
        TG_RELID,                                     -- relation OID for much quicker searches
        session_user::text,                           -- session_user_name
        current_timestamp,                            -- action_tstamp_tx
        statement_timestamp(),                        -- action_tstamp_stm
        clock_timestamp(),                            -- action_tstamp_clk
        txid_current(),                               -- transaction ID
        current_setting('application_name'),          -- client application
        inet_client_addr(),                           -- client_addr
        inet_client_port(),                           -- client_port
        current_query(),                              -- top-level query or queries (if multistatement) from client
        substring(TG_OP,1,1),                         -- action
        NULL, NULL,                                   -- row_data, changed_fields
        'f'                                           -- statement_only
        );

    IF NOT TG_ARGV[0]::boolean IS DISTINCT FROM 'f'::boolean THEN
        audit_row.client_query = NULL;
    END IF;

    IF TG_ARGV[1] IS NOT NULL THEN
        excluded_cols = TG_ARGV[1]::text[];
    END IF;

    IF (TG_OP = 'UPDATE' AND TG_LEVEL = 'ROW') THEN
        audit_row.row_data = hstore(OLD.*);
        audit_row.changed_fields =  (hstore(NEW.*) - audit_row.row_data) - excluded_cols;
        IF audit_row.changed_fields = hstore('') THEN
            -- All changed fields are ignored. Skip this update.
            RETURN NULL;
        END IF;
    ELSIF (TG_OP = 'DELETE' AND TG_LEVEL = 'ROW') THEN
        audit_row.row_data = hstore(OLD.*) - excluded_cols;
    ELSIF (TG_OP = 'INSERT' AND TG_LEVEL = 'ROW') THEN
        audit_row.row_data = hstore(NEW.*) - excluded_cols;
    ELSIF (TG_LEVEL = 'STATEMENT' AND TG_OP IN ('INSERT','UPDATE','DELETE','TRUNCATE')) THEN
        audit_row.statement_only = 't';
    ELSE
        RAISE EXCEPTION '[audit.if_modified_func] - Trigger func added as trigger for unhandled case: %, %',TG_OP, TG_LEVEL;
        RETURN NULL;
    END IF;
    INSERT INTO audit.logged_actions VALUES (audit_row.*);
    RETURN NULL;
END;
$body$
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = pg_catalog, public;


COMMENT ON FUNCTION audit.if_modified_func() IS $body$
Track changes to a table at the statement and/or row level.

Optional parameters to trigger in CREATE TRIGGER call:

param 0: boolean, whether to log the query text. Default 't'.

param 1: text[], columns to ignore in updates. Default [].

         Updates to ignored cols are omitted from changed_fields.

         Updates with only ignored cols changed are not inserted
         into the audit log.

         Almost all the processing work is still done for updates
         that ignored. If you need to save the load, you need to use
         WHEN clause on the trigger instead.

         No warning or error is issued if ignored_cols contains columns
         that do not exist in the target table. This lets you specify
         a standard set of ignored columns.

There is no parameter to disable logging of values. Add this trigger as
a 'FOR EACH STATEMENT' rather than 'FOR EACH ROW' trigger if you do not
want to log row values.

Note that the user name logged is the login role for the session. The audit trigger
cannot obtain the active role because it is reset by the SECURITY DEFINER invocation
of the audit trigger its self.
$body$;



CREATE OR REPLACE FUNCTION audit.audit_table(target_table regclass, audit_rows boolean, audit_query_text boolean, ignored_cols text[]) RETURNS void AS $body$
DECLARE
  stm_targets text = 'INSERT OR UPDATE OR DELETE OR TRUNCATE';
  _q_txt text;
  _ignored_cols_snip text = '';
BEGIN
    EXECUTE 'DROP TRIGGER IF EXISTS audit_trigger_row ON ' || target_table;
    EXECUTE 'DROP TRIGGER IF EXISTS audit_trigger_stm ON ' || target_table;

    IF audit_rows THEN
        IF array_length(ignored_cols,1) > 0 THEN
            _ignored_cols_snip = ', ' || quote_literal(ignored_cols);
        END IF;
        _q_txt = 'CREATE TRIGGER audit_trigger_row AFTER INSERT OR UPDATE OR DELETE ON ' ||
                 target_table ||
                 ' FOR EACH ROW EXECUTE PROCEDURE audit.if_modified_func(' ||
                 quote_literal(audit_query_text) || _ignored_cols_snip || ');';
        RAISE NOTICE '%',_q_txt;
        EXECUTE _q_txt;
        stm_targets = 'TRUNCATE';
    ELSE
    END IF;

    _q_txt = 'CREATE TRIGGER audit_trigger_stm AFTER ' || stm_targets || ' ON ' ||
             target_table ||
             ' FOR EACH STATEMENT EXECUTE PROCEDURE audit.if_modified_func('||
             quote_literal(audit_query_text) || ');';
    RAISE NOTICE '%',_q_txt;
    EXECUTE _q_txt;

END;
$body$
language 'plpgsql';

COMMENT ON FUNCTION audit.audit_table(regclass, boolean, boolean, text[]) IS $body$
Add auditing support to a table.

Arguments:
   target_table:     Table name, schema qualified if not on search_path
   audit_rows:       Record each row change, or only audit at a statement level
   audit_query_text: Record the text of the client query that triggered the audit event?
   ignored_cols:     Columns to exclude from update diffs, ignore updates that change only ignored cols.
$body$;

-- Pg doesn't allow variadic calls with 0 params, so provide a wrapper
CREATE OR REPLACE FUNCTION audit.audit_table(target_table regclass, audit_rows boolean, audit_query_text boolean) RETURNS void AS $body$
SELECT audit.audit_table($1, $2, $3, ARRAY[]::text[]);
$body$ LANGUAGE SQL;

-- And provide a convenience call wrapper for the simplest case
-- of row-level logging with no excluded cols and query logging enabled.
--
CREATE OR REPLACE FUNCTION audit.audit_table(target_table regclass) RETURNS void AS $$
SELECT audit.audit_table($1, BOOLEAN 't', BOOLEAN 't');
$$ LANGUAGE 'sql';

COMMENT ON FUNCTION audit.audit_table(regclass) IS $body$
Add auditing support to the given table. Row-level changes will be logged with full client query text. No cols are ignored.
$body$;

-- set up triggers using the following selects after import
-- select audit.audit_table('author');
-- select audit.audit_table('instance');
-- select audit.audit_table('name');
-- select audit.audit_table('reference');
alter table instance ADD CONSTRAINT citescheck check (cites_id is null or cited_by_id is not null);

-- fixing the column ordering in these indexes. Big effects on performance.

DROP INDEX idx_tree_node_taxon_in;
CREATE INDEX idx_tree_node_taxon_in ON tree_node (taxon_uri_id_part, taxon_uri_ns_part_id, tree_arrangement_id);

DROP INDEX idx_tree_node_name_in;
CREATE INDEX idx_tree_node_name_in ON tree_node (name_uri_id_part, name_uri_ns_part_id, tree_arrangement_id);

DROP INDEX idx_tree_node_resource_in;
CREATE INDEX idx_tree_node_resource_in ON tree_node (resource_uri_id_part, resource_uri_ns_part_id, tree_arrangement_id);

DROP INDEX idx_tree_node_name_id_in;
CREATE INDEX idx_tree_node_name_id_in ON tree_node (name_id, tree_arrangement_id);

DROP INDEX idx_tree_node_instance_id_in;
CREATE INDEX idx_tree_node_instance_id_in ON tree_node (instance_id, tree_arrangement_id);

create index name_lower_f_unaccent_full_name_like on name (lower(f_unaccent(full_name)) varchar_pattern_ops);
